Conocemos algunas estructuras de datos como son los vectores y matrices. No son las √∫nicas. Hay muchas situaciones donde utilizar alguna de estas estructuras nos proporcionar√° una soluci√≥n muy ineficiente (cantidad de espacio que ocupa en memoria, velocidad de acceso a la informaci√≥n, etc.)

Ejemplo 1. Imaginemos que debemos realizar un procesador de texto, debemos elegir la estructura de datos para almacenar en memoria las distintas l√≠neas que el operador ir√° tipeando. Una soluci√≥n factible es utilizar una matriz de caracteres. Pero como sabemos debemos especificar la cantidad de filas y columnas que ocupar√° de antemano. Podr√≠a ser por ejemplo 2000 filas y 200 columnas. Con esta definici√≥n estamos reservando de antemano 800000 bytes de la memoria, no importa si el operador despu√©s carga una l√≠nea con 20 caracteres, igualmente ya se ha reservado una cantidad de espacio que permanecer√° ociosa.

Tiene que existir alguna estructura de datos que pueda hacer m√°s eficiente la soluci√≥n del problema anterior.

Ejemplo 2. ¬øC√≥mo estar√°n codificadas las planillas de c√°lculo? ¬øReservar√°n espacio para cada casilla de la planilla al principio? Si no la lleno, ¬ølo mismo se habr√° reservado espacio?
Utilizar una matriz para almacenar todas las casillas de una planilla de c√°lculo seguro ser√° ineficiente.

Bien, todos estos problemas y muchos m√°s podr√°n ser resueltos en forma eficiente cuando conozcamos estas nuevas estructuras de datos (Listas, √°rboles)








Una lista es un conjunto de nodos, cada uno de los cuales tiene dos campos: uno de informaci√≥n y un apuntador al siguiente nodo de la lista. Adem√°s un apuntador externo se√±ala el primer nodo de la lista.

Representaci√≥n gr√°fica de un nodo:

Nodo
La informaci√≥n puede ser cualquier tipo de dato simple, estructura de datos o inclusive uno o m√°s objetos.
La direcci√≥n al siguiente nodo es un puntero.

Representaci√≥n gr√°fica de una lista:

lista
Como dec√≠amos, una lista es una secuencia de nodos (en este caso cuatro nodos). La informaci√≥n de los nodos en este caso es un entero y siempre contiene un puntero que guarda la direcci√≥n del siguiente nodo.
raiz es otro puntero externo a la lista que contiene la direcci√≥n del primer nodo.

El estado de una lista var√≠a durante la ejecuci√≥n del programa:

lista vacia
De esta forma representamos gr√°ficamente una lista vac√≠a.

Si insertamos un nodo en la lista quedar√≠a luego:

lista con un nodo
Si insertamos otro nodo al principio con el valor 9 tenemos:

lista con dos nodos
Lo mismo podemos borrar nodos de cualquier parte de la lista.
Esto nos trae a la mente el primer problema planteado: el desarrollo del procesador de texto. Podr√≠amos utilizar una lista que inicialmente estuviera vac√≠a e introduj√©ramos un nuevo nodo con cada l√≠nea que tipea el operador. Con esta estructura haremos un uso muy eficiente de la memoria.

Tipos de listas.
Seg√∫n el mecanismo de inserci√≥n y extracci√≥n de nodos en la lista tenemos los siguientes tipos:

Listas tipo pila.
Listas tipo cola.
Listas gen√©ricas.
Una lista se comporta como una pila si las inserciones y extracciones las hacemos por un mismo lado de la lista. Tambi√©n se las llama listas LIFO (Last In First Out - √∫ltimo en entrar primero en salir)

Una lista se comporta como una cola si las inserciones las hacemos al final y las extracciones las hacemos por el frente de la lista. Tambi√©n se las llama listas FIFO (First In First Out - primero en entrar primero en salir)

Una lista se comporta como gen√©rica cuando las inserciones y extracciones se realizan en cualquier parte de la lista.
Podemos en alg√∫n momento insertar un nodo en medio de la lista, en otro momento al final, borrar uno del frente, borrar uno del fondo o uno interior, etc.


En Java, cuando no pon√©s un modificador de acceso (como public, protected o private), se aplica el modificador por defecto llamado package‚Äëprivate. Eso significa que la clase o miembro solo es accesible dentro del mismo paquete.

En tu caso:
java
class Nodo {
    int info;
    Nodo sig;
}
Nodo es una clase interna (inner class) dentro de Pila.

Al no poner modificador, esa clase interna tiene visibilidad package‚Äëprivate.

Adem√°s, como es inner class no est√°tica, solo puede instanciarse desde una instancia de Pila y por c√≥digo que est√© en el mismo paquete.

En la pr√°ctica:

Ning√∫n c√≥digo fuera del paquete podr√° referirse directamente a Nodo.

Y aunque estuviera en el mismo paquete, si Nodo es solo para uso interno de Pila, no tiene sentido exponerlo p√∫blicamente.

üîπ Por qu√© se suele dejar sin modificador en este patr√≥n
Encapsulaci√≥n l√≥gica: Nodo es un detalle interno de implementaci√≥n de Pila, no parte de su API p√∫blica.

Menos superficie expuesta: evita que otro c√≥digo dependa de Nodo directamente.

Seguridad y mantenimiento: si cambi√°s la estructura de Nodo, no rompes c√≥digo externo porque nadie fuera deber√≠a usarlo.

üí° Extra: Podr√≠as incluso marcarlo private para hacerlo todav√≠a m√°s encapsulado:

java
private class Nodo {
    int info;
    Nodo sig;
}
Esto har√≠a que solo Pila (ni siquiera otras clases del paquete) pudiera usar Nodo.

Si quer√©s, te puedo mostrar un diagrama r√°pido de c√≥mo se ven las relaciones de accesibilidad entre Pila, Nodo y otras clases seg√∫n el modificador que uses. Te servir√≠a para visualizarlo mejor?